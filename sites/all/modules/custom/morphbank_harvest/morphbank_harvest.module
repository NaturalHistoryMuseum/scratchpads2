<?php
/**
 * @file
 * Harvest images from Morphbank for a selected vocabulary
 *
 * Currently uses taxonomic name to search; in an ideal world
 * the morphbank identifiers themselves could be stored in
 * Scratchpads (by altering the vocabulary fields).  This is
 * not currently possible, as of 28 January 2015, as the
 * services of Morphbank do not allow image query searches
 * using the identifiers of organisms.
 */
/**
 * The URL for the morphbank service; append 'request' for queries
 */
define("MORPHBANK_SERVICE", "http://services.morphbank.net/mb3/");
/**
 * The URL for morphbank records
 */
define("MORPHBANK_NET_URL", "http://morphbank.net/");
/**
 * The URL for morphbank images
 */
define("MORPHBANK_IMAGE_URL", "http://images.morphbank.net/");

/**
 * Implements hook_menu().
 */
function morphbank_harvest_menu(){
  $items['admin/config/system/morphbank_harvest'] = array(
    'title' => 'Morphbank harvest',
    'description' => t('Harvests images from Morphbank for a given vocabulary'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array(
      'morphbank_harvest_form'
    ),
    'access arguments' => array(
      'administer site configuration'
    ), // To restrict to adminstrators
    'access callback' => 'user_access',
    'type' => MENU_NORMAL_ITEM
  );
  return $items;
}

/**
 * Define the form.
 */
function morphbank_harvest_form(){
  // Start by getting a list of all biological vocabularies, for select element
  $biological_vids = variable_get('biological_vids', FALSE);
  if(!$biological_vids){
    drupal_set_message('There are no biological classifications on this site; Morphbank harvest requires a biologial classification.', 'warning');
  }else{
    foreach($biological_vids as $vid => $type){
      $vocabulary = taxonomy_vocabulary_load($vid);
      $taxonomies['morphbank_harvest_' . $vocabulary->vid] = $vocabulary->name;
    }
    // Make the select element
    $form['vid'] = array( // the name of the field is 'vid'
      '#type' => 'select',
      '#title' => '',
      '#options' => $taxonomies,
      '#empty_option' => t('Select vocabulary'),
      '#required' => TRUE
    );
    // How many images to save?  -1 means unlimited
    $form['maximages'] = array(
      '#type' => 'textfield',
      '#title' => t('Maximum number of images per taxon'),
      '#description' => t('(enter -1 for unlimited)'),
      '#default_value' => 10,
      '#element_validate' => array(
        'element_validate_integer'
      )
    );
    // Whether to search on 'unidentifieds'
    $form['searchunid'] = array(
      '#type' => 'checkbox',
      '#title' => t("Include 'unidentified' in search"),
      '#description' => t("If checked, harvest will perform queries for any taxa with 'unidentified' in the name; if unchecked, harvest skips those terms.")
    );
    // Whether to remove images that are no longer returned in search
    $form['removeold'] = array(
      '#type' => 'checkbox',
      '#title' => t("Remove images no longer returned in query"),
      '#description' => t("If checked, harvest will remove image files that are stored in Scratchpads, but are no longer returned by query; if unchecked, files that do not correspond to any records returned during this harvest will remain on disk."),
      '#default_value' => 1
    );
    // Whether to restrict search to ranks of species and below
    $form['restrictranks'] = array(
      '#type' => 'checkbox',
      '#title' => t("Restrict harvest to terms of rank species and below"),
      '#description' => t("If checked, harvest will only perform Morphbank queries for terms of the following ranks: form, species, subform, subspecies, subvariety, variety"),
      '#default_value' => 1
    );
    // Maximum number of errors to report after harvest, -1 means unlimited
    $form['maxerrors'] = array(
      '#type' => 'textfield',
      '#title' => t('Maximum number of errors to report'),
      '#description' => t('(enter -1 for unlimited)'),
      '#default_value' => 4,
      '#element_validate' => array(
        'element_validate_integer'
      )
    );
    // The submit button for the form
    $form['submit'] = array(
      '#type' => 'submit',
      '#value' => t('Harvest')
    );
    return $form;
  }
}

/**
 * Verify that the values in submitted form are valid.
 *
 * Specifically, makes sure that values in 'maximages' and 'maxerrors' fields are
 *   either a positive integer or -1 (for an unlimited number)
 * @param array $form  The form, as an array
 * @param unknown_type $form_state
 *   The form values
 */
function morphbank_harvest_form_validate($form, &$form_state){
  // Make sure max number of images is ok
  $max_images = $form_state['values']['maximages'];
  $max_images_ok = FALSE;
  if(is_numeric($max_images)){
    if($max_images == -1 || $max_images >= 0){
      $max_images_ok = TRUE;
    }
  }
  if(!$max_images_ok){
    form_set_error('maximages', t('Maximum number of images per taxon must be a positive integer, 0, or -1 (@maximages is not a valid value).', array(
      '@maximages' => $max_images
    )));
  }
  // Make sure max number of errors is ok
  $max_errors = $form_state['values']['maxerrors'];
  $max_errors_ok = FALSE;
  if(is_numeric($max_errors)){
    if($max_errors == -1 || $max_errors >= 0){
      $max_errors_ok = TRUE;
    }
  }
  if(!$max_errors_ok){
    form_set_error('maxerrors', t('Maximum number of errors to report must be a positive integer, 0, or -1 (@maxerrors is not a valid value).', array(
      '@maxerrors' => $max_errors
    )));
  }
}

/**
 * Post-validation action on when form is submitted
 *
 * Starts the query cascade for harvesting images from Morphbank
 *
 * @param  $form
 * @param  $form_state
 *   The form from which to harvest values (maximages, searchunid, removeold, restrictranks, maxerrors)
 */
function morphbank_harvest_form_submit($form, &$form_state){
  // Define batch and operations here, move most of the guts to another method
  // We want one batch per term.
  $time_start = time();
  // Find out how many images to save
  $maximages = -1;
  if($form_state['values']['maximages'] >= 0){
    $maximages = $form_state['values']['maximages'];
  }
  // See if we are to skip the unidentifieds
  $search_unidentifieds = FALSE;
  if($form_state['values']['searchunid'] == 1){
    $search_unidentifieds = TRUE;
  }
  // See if we are to remove images not returned in this latest harvest
  $remove_old_files = FALSE;
  if($form_state['values']['removeold'] == 1){
    $remove_old_files = TRUE;
  }
  // See if we are restricting the ranks to perform harvest on
  $restrict_ranks = FALSE;
  if($form_state['values']['restrictranks'] == 1){
    $restrict_ranks = TRUE;
    $ranks_to_harvest = array(
      'form',
      'species',
      'subform',
      'subspecies',
      'subvariety',
      'variety'
    );
  }
  // How many errors to report
  $maxerrors = -1;
  if($form_state['values']['maxerrors'] >= 0){
    $maxerrors = $form_state['values']['maxerrors'];
  }
  // get the selected vid (the biological vocabulary that will supply term names)
  $vid_string = $form_state['values']['vid'];
  $vid = str_replace('morphbank_harvest_', '', $vid_string);
  // get the corresponding taxonomy for this vocabulary
  $taxonomy = taxonomy_get_tree($vid);
  if(!is_null($taxonomy) && count($taxonomy) > 0){
    $problem = FALSE;
    // Get some values for the morphbank_harvests table
    $sid = $search_unidentifieds ? 1 : 0;
    $rem = $remove_old_files ? 1 : 0;
    $restrict = $restrict_ranks ? 1 : 0;
    $timestamp = time();
    // Before cycling over taxonomy, add a record to morphbank_harvests table
    $hid = db_insert('morphbank_harvests')->fields(array(
      'search_unidentified' => $sid,
      'max_images' => $maximages,
      'remove_old' => $rem,
      'restrict_ranks' => $restrict,
      'execution_date' => $timestamp,
      'problem' => 1
    ))->execute();
    if($hid > 0){
      if(file_get_contents(MORPHBANK_SERVICE)){
        // Set up the batch job
        $batch = array(
          'title' => t('Harvesting images ...'),
          'operations' => array(),
          'init_message' => t('Harvest begins'),
          'progress_message' => t('Processed @current out of @total terms.'),
          'error_message' => t('An error occurred during harvest'),
          'finished' => 'morphbank_harvest_finished'
        );
        $batch_details = array(
          'hid' => $hid,
          'maxerrors' => $maxerrors,
          'time_start' => $time_start
        );
        $batch['operations'][] = array(
          '_store_hid_maxerrors',
          array(
            $batch_details
          )
        );
        // Array that will be sent to _harvest_from_morphbank, along with term,
        // to dictate settings for query to Morphbank
        $harvest_details = array(
          'hid' => $hid,
          'search_unidentifieds' => $search_unidentifieds,
          'restrict_ranks' => $restrict_ranks,
          'ranks_to_harvest' => $ranks_to_harvest,
          'maximages' => $maximages
        );
        // proceed only if maximages does not equal zero (it is a positive integer or -1)
        if($maximages != 0){
          // Loop over each term in the taxonomy
          foreach($taxonomy as $term){
            // Add the term to the array we will send to _harvest_from_morphbank
            $harvest_details['term'] = $term;
            // Submit one batch operation for each term
            $batch['operations'][] = array(
              '_harvest_from_morphbank',
              array(
                $harvest_details
              )
            );
          } // end looping over all terms.
        }
        // Remove any old files (those that were not returned in query) due to (1) changes
        // on Morphbank's end or (2) a reduction in the maximum number of images to harvest.
        if($remove_old_files){
          $batch['operations'][] = array(
            '_post_harvest_cleanup',
            array(
              array(
                'hid' => $hid
              )
            )
          );
        }
        batch_set($batch);
      }      // end conditional for responsive Morphbank
else{
        drupal_set_message(t('Morphbank service at @morphbank_url is unresponsive', array(
          '@morphbank_url' => MORPHBANK_SERVICE
        )), 'error');
      }
    }    // end conditional for positive $hid (we successfully added record to morphbank_harvests table)
else{
      drupal_set_message(t('Could not access morphbank_harvest_table'), 'error');
    }
  }else{
    drupal_set_message(t('Empty vocabulary selected (vid = @vid)', array(
      '@vid' => $vid
    )));
  }
}

/**
 * Store the harvest id (hid) and maximum number of errors to report in results array
 * so we can access it later.  Also establishes counter indicies.
 *
 * @param array  $hid_array
 *   A two-element array with the element 'hid' storing the integer corresponding
 *   to the harvest id and 'maxerrors' storing the maximum number of errors to report
 *
 * @param array  $context
 *   Array holding batch results
 */
function _store_hid_maxerrors($details_array, &$context){
  $context['results']['hid'] = $details_array['hid'];
  $context['results']['maxerrors'] = $details_array['maxerrors'];
  $context['results']['time_start'] = $details_array['time_start'];
  // Establish all the counting arrays to avoid undefined index errors
  $context['results']['num_added'] = 0;
  $context['results']['num_changed'] = 0;
  $context['results']['num_unchanged'] = 0;
  $context['results']['num_deleted'] = 0;
  $context['results']['num_queries'] = 0;
  $context['results']['num_no_images'] = 0;
  // Establish arrays to hold errors
  $context['results']['missing_elements'] = array();
  $context['results']['morphbank_unresponsive'] = array();
}

/**
 * Perform morphbank harvest for term
 *
 * @param array  $harvest_details
 *   Array with details about the harvest, including the following elements:
 *   'search_unidentifieds' => whether or not to search terms with 'unidentified' in the name
 *   'restrict_ranks' => whether or not to restrict search to ranks of species and below
 *   'ranks_to_harvest' => array of strings with ranks to harvest (or NULL if $restrict_ranks == FALSE)
 *   'maximages' => the maximum number of images to harvest for any one term
 *   'term' => the term to harvest images for
 *
 * @param array  $context
 *   array to store results of harvest, including the number of queries, images found, and any
 *   problems that may have occurred
 */
function _harvest_from_morphbank($harvest_details, &$context){
  // Extract values from array
  $hid = $harvest_details['hid'];
  $search_unidentifieds = $harvest_details['search_unidentifieds'];
  $restrict_ranks = $harvest_details['restrict_ranks'];
  $ranks_to_harvest = $harvest_details['ranks_to_harvest'];
  $maximages = $harvest_details['maximages'];
  $term = $harvest_details['term'];
  $term_name = $term->name;
  $tid = $term->tid;
  // We now have term name.
  // 1. Perform morphbank query  _query_morphbank
  // 2. Process response         _process_response
  //      If no images, move to next term;
  //      if images, loop over them ($maximages is sent in query, so loop iterations should never exceed $maximages)
  //        i. Get images from Morphbank.  (called by _process_response)
  //          Check to see if file already exists using original_filename and morphbank ID
  //          If it isn't there save file  _retrieve_morphbank_image
  //          After saving file, get the fid from the file object, fid = file->fid;
  //        ii. File has been saved, now we need to see if any specimens of this taxon have morphbank_ids
  //          by call to _update_specimen_links:
  //          Perform database query on field_morphbank_specimen_id to see if any specimens match
  //          If so, update field_media field.
  //        iii. Now that we have the file, call _update_file_links to:
  //          a. Link the file to the taxonomy term we just searched on (field_taxonomic_name)
  //          b. Link the imaging preparation technique term associated with the Morphbank view ID that was
  //              included in the XML response.  For link to be made, requires field_morphbank_view_id of
  //              terms to be not NULL.  If match is made, update the file's field_imaging_technique field
  //          c. Finally, remove any specimens that may have once been linked to the image but no longer have
  //              matching Morphbank specimen IDs.
  $skip = FALSE;
  // If this is unidentified, do we want to perform search?
  if(!$search_unidentifieds){
    // Want to skip unidentifieds, so see if the string is in the name
    if(strpos($term_name, 'unidentified') === FALSE){ // use === in case the name string starts with 'unidentified' (and would return zero, which would evaluate to TRUE for comparison 0 == FALSE )
      // No 'unidentified' in string, so go ahead and include
    }else{
      // Found the string, so we will skip the record
      $skip = TRUE;
    }
  }
  // Check rank, if rank restriction was selected
  if($restrict_ranks && !$skip){
    $skip = TRUE;
    $term_wrapper = entity_metadata_wrapper('taxonomy_term', $term->tid);
    if($term_wrapper){
      $term_rank = $term_wrapper->field_rank->value();
      if($term_rank){
        $term_rank = strtolower($term_rank);
        if(in_array($term_rank, $ranks_to_harvest)){
          $skip = FALSE;
        }
      } // End conditional for non-null $term_rank
    } // End conditional for non-null $term_wrapper
  } // End conditional for restricting ranks if not already skipping record
  // So long as we are not skipping this term, start harvest process
  if(!$skip){
    // Message to print while batch processing
    $context['message'] = t('Querying Morphbank for @term_name images', array(
      '@term_name' => $term_name
    ));
    // Make sure Morphbank is responsive
    if(file_get_contents(MORPHBANK_SERVICE)){
      $responses = _query_morphbank($term_name, $maximages);
      if(is_array($responses)){ // The numReturned element was not empty (see _query_morphbank)
        $context['results']['num_queries']++;
        // Uncomment for more verbose response per query
        // $num_images = count($responses);
        // drupal_set_message(t('***   @num_images images for term @term_name', array('@num_images' => $num_images, '@term_name' => $term_name)));
        if(count($responses) == 0){ // No images were returned from query
          $context['results']['num_no_images']++;
        }else{ // An array of SimpleXLMObjects returned
          foreach($responses as $morphbank_response){
            $result = _process_response($morphbank_response, $term_name, $tid, $hid);
            $found_result = FALSE;
            switch($result){
              case 'a':
                $context['results']['num_added']++;
                $found_result = TRUE;
                break;
              case 'c':
                $context['results']['num_changed']++;
                $found_result = TRUE;
                break;
              case 'u':
                $context['results']['num_unchanged']++;
                $found_result = TRUE;
                break;
            } // end switch on $result
          } // end looping over responses
        } // end else for some images found
      }else{ // The numReturned element wasn't found in the response
        $context['results']['missing_elements'][] = $term_name;
      }
    }else{ // Morphbank is unresponsive
      $context['results']['morphbank_unresponsive'][] = $term_name;
    }
  } // end conditional for record not to skip ($skip == FALSE)
}

/**
 * Update morphbank_images table and remove files and/or links that are
 *   obsolete.
 *
 * @param array $post_harvest_details
 *   A single-element array containing harvest ID ('hid')
 *
 * @param array $context
 *   Array from batch processing, passed as reference.  Used here to store
 *   number of images deleted in cleanup.
 */
function _post_harvest_cleanup($post_harvest_details, &$context){
  $hid = $post_harvest_details['hid'];
  $files_to_remove = db_select('morphbank_images', 'm')->fields('m', array(
    'fid'
  ))->condition('hid', $hid, '<>')->execute();
  $num_to_remove = $files_to_remove->rowCount();
  if($num_to_remove > 0){
    $fids_remove = array();
    foreach($files_to_remove as $to_remove){
      $fids_remove[] = $to_remove->fid;
    }
    // Start with removal of links in morphbank_images table
    foreach($fids_remove as $fid){
      $delete = db_delete('morphbank_images')->condition('fid', $fid)->execute();
      if($delete){
        $context['results']['num_deleted']++;
      }
    }
    // Then delete the file entities (ideally removes references to the entity
    // in field_*_field_media, field_*_field_taxonomic_name, field_*_field_imaging_technique,
    // and field_*_field_morphbank_image_id, where * is 'data' and 'revision')
    entity_delete_multiple('file', $fids_remove);
  }
}

/**
 * Report results of harvest.
 *
 * @param unknown_type $success
 * @param array $results
 * @param array $operations
 *
 * <p>Uses values stored in $results array to report results of morphbank image harvest.</p>
 * <p>Reports problems that may have been encountered.</p>
 */
function morphbank_harvest_finished($success, $results, $operations){
  // Extract values of interest
  $hid = $results['hid'];
  $maxerrors = $results['maxerrors'];
  $num_added = $results['num_added'];
  $num_changed = $results['num_changed'];
  $num_unchanged = $results['num_unchanged'];
  $num_deleted = $results['num_deleted'];
  $num_queries = $results['num_queries'];
  $num_no_images = $results['num_no_images'];
  $time_start = $results['time_start'];
  drupal_set_message(t('Morphbank harvest complete'));
  $time_end = time();
  $total_seconds = $time_end - $time_start;
  drupal_set_message(t('Total time: @time seconds', array(
    '@time' => $total_seconds
  )));
  // Report number of images added, changed, etc.
  drupal_set_message(t('@added added', array(
    '@added' => format_plural($num_added, '1 image', '@num_added images', array(
      '@num_added' => $num_added
    ))
  )));
  drupal_set_message(t('@changed updated', array(
    '@changed' => format_plural($num_changed, '1 image', '@num_changed images', array(
      '@num_changed' => $num_changed
    ))
  )));
  drupal_set_message(t('@unchanged unchanged', array(
    '@unchanged' => format_plural($num_unchanged, '1 image', '@num_unchanged images', array(
      '@num_unchanged' => $num_unchanged
    ))
  )));
  drupal_set_message(t('@deleted deleted', array(
    '@deleted' => format_plural($num_deleted, '1 image', '@num_deleted images', array(
      '@num_deleted' => $num_deleted
    ))
  )));
  drupal_set_message(t('@queries successfully performed', array(
    '@queries' => format_plural($num_queries, '1 query', '@num_queries queries', array(
      '@num_queries' => $num_queries
    ))
  )));
  drupal_set_message(t('@no_images had no corresponding images on Morphbank', array(
    '@no_images' => format_plural($num_no_images, '1 term', '@no_images terms', array(
      '@no_images' => $num_no_images
    ))
  )));
  // See if there were any problems
  $problem_arrays = array(
    'missing_elements' => 'invalid response',
    'morphbank_unresponsive' => 'morphbank unresponsive'
  );
  $no_problems = TRUE;
  foreach($problem_arrays as $problem => $description){
    $reported = 0;
    $total = count($results[$problem]);
    if($total > 0){
      $no_problems = FALSE;
    }
    // Make sure errors are supposed to be reported
    if($maxerrors != 0){
      // only report $maxerrors; unless $maxerrors = -1, then report them all
      while(($reported < $maxerrors && $reported < $total) || $maxerrors == -1){
        $message_array = array(
          '@term_name' => $term_name,
          '@description' => $description
        );
        drupal_set_message(t('Query for term \'@term_name\' returned: @description.', $message_array), 'error');
        $reported++;
      }
      if($reported < $total){
        $message_array = array(
          '@total' => $total,
          '@description' => $description
        );
        drupal_set_message(t('(@total additional \'@description\' errors not shown)', $message_array), 'error');
      }
    } // End conditional for $maxerrors != 0
  } // End loop over $problem_arrays
  // If no problems encountered, update the morphbank_harvests table to indicate zero problems
  if($no_problems){
    $num_updated = db_update('morphbank_harvests')->fields(array(
      'problem' => 0
    ))->condition('hid', $hid, "=")->execute();
  }
}

/**
 * Peform Morphbank query on passed $term_name
 *
 * @param string $term_name
 *   The term name to perform Taxonomic name search on
 *
 * @param int $maximages
 *   The maximum number of images to return
 *
 * @return mixed
 *   If query was successful and returned objects, returns indexed array of XML objects correpsonding
 *   to 'object type = "Image"' elements in Morphbank response; if the numReturned was 0, returns an
 *   empty array; in the case of an unsuccessful query (or one in which the numReturned element was
 *   missing from resultant XML), returns FALSE.
 */
function _query_morphbank($term_name, $maximages){
  $search_terms = array(
    'method' => 'taxon',
    'objecttype' => 'Image',
    'format' => 'svc',
    'taxonName' => $term_name,
    'limit' => $maximages
  );
  // Encode the query parameters for URL
  $encoded_parameters = array();
  foreach($search_terms as $key => $value){
    $encoded_parameters[] = urlencode($key) . '=' . urlencode($value);
  }
  // Build the query string
  $query_string = implode('&', $encoded_parameters);
  // Build the url
  $request_url = MORPHBANK_SERVICE . 'request?' . $query_string;
  // Make the request
  $result = drupal_http_request($request_url);
  //Make sure code == 200
  $code = $result->code;
  if($code == 200){ // What about 201?
    // Convert the 'data' object returned from drupal_http_request from string to an XML object
    // Suppressing warning in case Morphbank is returning malformed XML
    if($response_xml = simplexml_load_string($result->data, "SimpleXMLElement", $options = LIBXML_NOERROR)){
      if(is_null($response_xml->numReturned)){        // No numReturned element, something probably went wrong
return FALSE;}
      $response_array = array();
      foreach($response_xml->object as $object){
        $obj_attributes = $object->attributes();
        if($obj_attributes['type'] == "Image"){
          $response_array[] = $object;
        }
      }
      return $response_array;
    }
    watchdog('morphbank_harvest', 'Malformed XML returned for query on @term_name', array(
      '@term_name' => $term_name
    ), WATCHDOG_NOTICE);
  }  // End conditional for success response code
else{
    watchdog('morphbank_harvest', 'Unsuccessful response code (@response_code) query on @term_name', array(
      '@response_code' => $code,
      '@term_name' => $term_name
    ), WATCHDOG_NOTICE);
  }
  return FALSE;
}

/**
 * Processes a XML object corresponding to a single Morphbank image record.
 *
 * Extracts relevant element values from $response.  If this record (as identified
 *   by the Morphbank ID) is new (no record in morphbank_images table), it adds
 *   a record to the table; if the record is *not* new, checks the date of last
 *   modification (in the XML as dateLastModified element).  If the record has
 *   been updated on Morphbank since the last harvest (as recorded in
 *   morphbank_images.last_modified field), it updates the morphbank_images record.
 *
 * After comparing ages, if the record is new(er), retrieves the image file from
 *   Morphbank, renames the file, and saves the file to the public://morphbank
 *   directory.
 *
 * Calls _update_specimen_links to update links between image files and Specimen/
 *   Observation nodes.
 *
 * Calls _update_file_links to update links between image files and
 *   (1) the term the search is performed on and (2) the image preparation technique
 *   term corresponding to the Morphbank view.
 *
 * Calls _remove_outdated_links to remove any links that are no longer appropriate (e.g.
 *   if the Morphbank specimen ID has changed).
 *
 * @param SimpleXMLObject $response
 *   XML object correpsonding to 'object type = "Image"' element in a Morphbank response
 *
 * @param string $term_name
 *   The term name used for the query that produced this response, primarily used here
 *   to create file name
 *
 * @return mixed
 *   If record successfully processed, returns 'a' for images that were not previously in
 *   database (but are now); returns 'c' for images that were in database, but had
 *   changed since last harvest (and are now updated); and returns 'u' for images that
 *   were in the database and returned in query, but had not changed since the last
 *   harvest (and were thus not updated, although the hid is updated).  If record was
 *   not successfully processed, returns FALSE.
 *
 * @see _update_specimen_links
 * @see _update_file_links
 * @see _remove_outdated_links
 */
function _process_response($response, $term_name, $tid, $hid){
  $to_return = FALSE;
  // Want to retrieve the image id
  $source_id_element = $response->sourceId;
  $morphbank_image_id = (int)$source_id_element->morphbank;
  // Want to retrieve the view id (to link file to Image Preparation Technique vocabulary later)
  $view_element = $response->view;
  $morphbank_view_id = (int)$view_element->morphbank;
  // Convert to Unix timestamp (seconds since Unix era)
  $last_changed_on_morphbank = date(strtotime($response->dateLastModified));
  // See if we have a record for this image ID already
  $query_result = db_select('morphbank_images', 'm')->fields('m', array(
    'mid',
    'last_modified',
    'fid'
  ))->condition('morphbank_image_id', $morphbank_image_id)->execute();
  $on_disk = $query_result->rowCount(); // do not use count($query_result)
  $get_file = TRUE;
  if($on_disk){
    foreach($query_result as $one_result){
      $last_changed_on_disk = $one_result->last_modified;
      $mid = $one_result->mid;
      // If timestamp is same age or younger, do not get the image file from Morphbank
      if($last_changed_on_disk >= $last_changed_on_morphbank){
        $get_file = FALSE;
        $fid = $one_result->fid; // We may need this later
      }
    }
  }
  if($get_file){
    $original_filename = $response->originalFileName;
    $fid = _retrieve_morphbank_image($morphbank_image_id, $term_name, $original_filename);
  }
  if($fid){
    $morphbank_specimen = $response->specimen;
    $morphbank_specimen_id = (int)$morphbank_specimen->morphbank;
    // Perform update/insert on morphbank_images table as appropriate
    if($get_file){ // Did we add/update the file?
      if($on_disk){ // Updated (changed)
        if($mid > 0){ // We have the id of the record in morphbank_images that we need to update
          $num_updated = db_update('morphbank_images')->fields(array(
            'morphbank_image_id' => $morphbank_image_id,
            'last_modified' => $last_changed_on_morphbank,
            'morphbank_specimen_id' => $morphbank_specimen_id,
            'fid' => $fid,
            'hid' => $hid,
            'original_filename' => "{$original_filename}"
          ))->condition('mid', $mid, '=')->execute();
          if($num_updated > 0){
            $to_return = 'c';
          }
        } // End conditional for valid morphbank image id ($mid)
      }else{ // Added (image was not already on disk)
        // Insert a new record into morphbank_images
        $mid = db_insert('morphbank_images')->fields(array(
          'morphbank_image_id' => $morphbank_image_id,
          'last_modified' => $last_changed_on_morphbank,
          'morphbank_specimen_id' => $morphbank_specimen_id,
          'fid' => $fid,
          'hid' => $hid,
          'original_filename' => "{$original_filename}"
        ))->execute();
        if($mid > 0){
          $to_return = 'a';
        }
      } // End else for file not already on disk
    }else{ // We did not retrieve the file (dates of last change match), but it was returned in the query, so update hid in morphbank_images
      // If record is not updated with hid, it will be deleted if user selects remove old files
      if($mid > 0){
        $num_updated = db_update('morphbank_images')->fields(array(
          'hid' => $hid
        ))->condition('mid', $mid, '=')->execute();
        if($num_updated > 0){
          $to_return = 'u';
        }
      }
    } // End else for latest version of file already on disk
    // Either (1) file has been written or (2) the image did not need
    // to be downloaded again; either way, we have the fid.
    // Now need to check for adding links to Specimen/Observation nodes
    _update_specimen_links($fid, $morphbank_specimen_id);
    // Also want to link the file to the term we just searched on, and include Morphbank's image ID
    _update_file_links($fid, $tid, $morphbank_view_id, $morphbank_image_id);
    // Finally, check to see if any links to Specimen/Observation nodes need to be removed (say, for example, if the
    // Morphbank specimen ID changed)
    _remove_outdated_links($fid, $morphbank_specimen_id);
  }
  return $to_return;
}

/**
 * Retrieves a jpg image file from Morphbank for passed $morphbank_image_id and saves to
 *   public://morphbank directory.  Returns resultant fid on success, FALSE on failure.
 *
 * @param int $morphbank_image_id
 *   The Morphbank ID for the image to retrieve
 *
 * @param string $term_name
 *   The term name used for the query that produced this response, primarily used here
 *   to create file name
 *
 * @param string $original_filename
 *   The original name of the image file uploaded to Morphbank, primarily used here
 *   to create file name
 *
 * @return mixed
 *   If a file is retrieved from Morphbank and saved to disk, returns the fid (int)
 *   of the file (as listed in file_managed table); if no file was saved, returns FALSE.
 */
function _retrieve_morphbank_image($morphbank_image_id, $term_name, $original_filename){
  if($morphbank_image_id > 0){
    $image_location = MORPHBANK_IMAGE_URL . '?id=' . $morphbank_image_id . '&imgType=jpg';
    $destination_directory = variable_get('file_default_scheme', 'public') . '://morphbank';
    if(file_prepare_directory($destination_directory, FILE_CREATE_DIRECTORY)){
      // For the file name, will want the taxonomic name, the morphbank id, and the original file name
      // Keeping this info will make it easier for users to find the files they are looking for
      // Replace whitespace with dashes for file name
      $name_string = preg_replace('/\s+/', '-', $term_name);
      // Replace plus sign with dashes
      $name_string = str_replace('+', '-', $name_string);
      $new_file_name = $name_string . '-' . $morphbank_image_id . '-' . $original_filename;
      if(strpos(strtolower($new_file_name), ".jpg") == 0){
        // No .jpg, see if there's a jpeg
        if(strpos(strtolower($new_file_name), ".jpeg") == 0){
          // No .jpeg, just append .jpg
          $new_file_name = $new_file_name . '.jpg';
        }else{
          // Replace .jpeg with .jpg
          $new_file_name = str_ireplace('.jpeg', '.jpg', $new_file_name);
        }
      }
      $destination = file_stream_wrapper_uri_normalize($destination_directory . '/' . $new_file_name);
      $image = file_get_contents($image_location);
      // This save sets status == 1
      $file = file_save_data($image, $destination, FILE_EXISTS_REPLACE); // Replaces file if already exists
      if(is_object($file)){
        $fid = $file->fid;
        return $fid;
      }
    }
  }
  return FALSE;
}

/**
 * Links any Scratchpads Specimen/Observation nodes with $morphank_specimen_id to
 *   the passed $fid (via the field_media field).  Skips nodes that are already
 *   linked to this $fid.
 *
 * @param int $fid
 *   The id of the file
 *
 * @param int $morphbank_specimen_id
 *   The Morphbank ID of the specimen
 */
function _update_specimen_links($fid, $morphbank_specimen_id){
  if($fid > 0 && $morphbank_specimen_id > 0){
    // Get the nodes with the passed $morphbank_specimen_id
    $node_query = new EntityFieldQuery();
    $node_query->entityCondition('entity_type', 'node')->entityCondition('bundle', 'specimen_observation')->fieldCondition('field_morphbank_specimen_id', 'value', $morphbank_specimen_id, '=');
    $node_result = $node_query->execute();
    if(array_key_exists('node', $node_result) && count($node_result['node']) > 0){
      $node_ids = array_keys($node_result['node']);
      // Cycle over ALL results.  Duplicate specimens (even if they should not exist) may cause issues
      foreach($node_ids as $nid){
        $node = node_load($nid);
        $file = file_load($fid);
        if($file){
          $wrapper = entity_metadata_wrapper('node', $node);
          if($wrapper){
            $current_list = $wrapper->field_media->value(); // this is an array
            if(!$current_list){
              $current_list = array();
            }
            //Make sure this file is not already attached to this node (via fid)
            $make_link = TRUE;
            foreach($current_list as $list_item){
              if($fid == $list_item['fid']){ // There is already a link, so no need to update
                $make_link = FALSE;
                break;
              }
            }
            if($make_link){
              // Have to cast the file as an array before attaching it to node
              $file_as_array = (array)$file;
              // Have to add a 'display' element
              $file_as_array['display'] = 1;
              $file_as_array['description'] = 'image file retreived from Morphbank';
              // Add this new file to current list
              $current_list[] = $file_as_array;
              // Before we actually add the list, want to make sure of two things:
              // (1) all the elements in the list are arrays
              // (2) all the files in the list actually exist
              $new_list = array();
              foreach($current_list as $list_item){
                if(is_array($list_item)){ // Check (1)
                  $fid_to_check = $list_item['fid'];
                  if(file_load($fid_to_check)){ // Check (2)
                    $new_list[] = $list_item;
                  }
                }
              }
              // only update the field if we have made changes (and the list is not empty)
              // Let _post_harvest_cleanup remove any obsolete links
              if(count($new_list) > 0){
                try{
                  $wrapper->field_media->set($new_list);
                  $wrapper->save();
                }
                catch(Exception $exception){
                  $exception_class = get_class($exception);
                  watchdog('morphbank_harvest', t('Exception @class caught while attempting to link file @fid and specimen with morphbank id @morphbank_specimen_id'), array(
                    '@class' => $exception_class,
                    '@fid' => $fid,
                    '@morphbank_specimen_id' => $morphbank_specimen_id
                  ), WATCHDOG_WARNING);
                }
              }
            } // End conditional for $make_link
          } // End conditional for non-null $wrapper
        } // End conditional for non-null $file
      } // End looping over all $node_ids
    } // End conditional for at least one result
  } // End conditional for $fid > 0 and $morphbank_specimen_id > 0
}

/**
 * Updates file entity's field_taxononomic_name field and imaging_technique field;
 *   For taxonomic name, creates link between the file identified by $fid and the
 *   term identified by $tid.
 *   For imaging technique, checks to see if any terms in the imaging_technique
 *   vocabulary have a value in field_morphbank_view_id that matches passed
 *   $morphbank_view_id.  If so, updates field_imaging_technique for file identified
 *   by $fid and the appropriate term ID in the imaging_technique vocabulary.
 *   Also stores the Morphbank image ID in the image file content
 *
 * @param int $fid
 *   The file ID of the file we just added
 *
 * @param int $tid
 *   The term ID of the term we just searched on (and recovered this file from search)
 *
 * @param int $morphbank_view_id
 *   The identifier of the view for this image in the Morphbank system; used to link to
 *   an Imaging Preparation Technique term
 *
 * @param int $morphbank_image_id
 *   The identifier of the image in the Morphbank system; just serves storage purpose now
 */
function _update_file_links($fid, $tid, $morphbank_view_id, $morphbank_image_id){
  if($fid > 0 && $tid > 0){
    $entity_wrapper = entity_metadata_wrapper('file', $fid);
    if($entity_wrapper){
      // ------------------------------------ //
      // First part: link to the taxonomy term we just searched on,
      // over-writing any values that are already there
      // ------------------------------------ //
      $new_list = array();
      $term_as_array = (array)$tid;
      $new_list[] = $term_as_array;
      try{
        $entity_wrapper->field_taxonomic_name->set($new_list);
        $entity_wrapper->save();
      }
      catch(Exception $exception){
        $exception_class = get_class($exception);
        watchdog('morphbank_harvest', t('Exception @class caught while attempting to link file @fid and taxonomy term @term'), array(
          '@class' => $exception_class,
          '@fid' => $fid,
          '@term' => $tid
        ), WATCHDOG_WARNING);
      }
      // ------------------------------------ //
      // Second part: see if there is a term in Image Preparation Technique with this Morphbank View ID
      // ------------------------------------ //
      $vocabularies = taxonomy_get_vocabularies();
      foreach($vocabularies as $vocabulary){
        if($vocabulary->machine_name == 'imaging_technique'){
          $imaging_vid = $vocabulary->vid;
          break;
        }
      }
      $imaging_tid = -1;
      if($imaging_vid > 0){ // found the vocabulary
        $imaging_terms = taxonomy_get_tree($imaging_vid);
        if(!is_null($imaging_terms) && count($imaging_terms) > 0){
          foreach($imaging_terms as $imaging_term){ // This could probably be streamlined by using a database query
            $term_wrapper = entity_metadata_wrapper('taxonomy_term', $imaging_term->tid);
            if($term_wrapper){
              $term_view_id = $term_wrapper->field_morphbank_view_id->value();
              if($term_view_id > 0){
                if($morphbank_view_id == $term_view_id){
                  $imaging_tid = $imaging_term->tid;
                  break;
                }
              } // End conditional for valid (positive) $term_view_id
            } // End conditional for non-null $term_wrapper
          } // End looping over all imaging terms
        } // End conditional for non-null and non-empty $imaging_terms
        // Found a term in the imaging vocabulary with this morphbank_view_id, so link the file to this imaging term
        if($imaging_tid > 0){
          try{
            $entity_wrapper->field_imaging_technique->set($imaging_tid);
            $entity_wrapper->save();
          }
          catch(Exception $exception){
            $exception_class = get_class($exception);
            watchdog('morphbank_harvest', t('Exception @class caught while attempting to link file @fid and taxonomy term @term'), array(
              '@class' => $exception_class,
              '@fid' => $fid,
              '@term' => $tid
            ), WATCHDOG_WARNING);
          }
        } // End conditional for valid (positive) $imaging_tid
      } // End conditional for valid (positive) $imaging_vid
      // ------------------------------------ //
      // Third part: add the Morphbank image ID to the file
      // ------------------------------------ //
      if($morphbank_image_id > 0){
        try{
          $entity_wrapper->field_morphbank_image_id->set($morphbank_image_id);
          $entity_wrapper->save();
        }
        catch(Exception $exception){
          $exception_class = get_class($exception);
          watchdog('morphbank_harvest', t('Exception @class caught while attempting to link file @fid and taxonomy term @term'), array(
            '@class' => $exception_class,
            '@fid' => $fid,
            '@term' => $tid
          ), WATCHDOG_WARNING);
        }
      }
    }
  }
}

/**
 * Removes any obsolete links between Specimen/Observation nodes and images
 * harvested from Morphbank.
 *
 * If any Scratchpads Specimen/Observation nodes that are linked to the image
 *   in the field_data_field_media table do *not* have the same specimen
 *   Morphbank ID, removes links using entity wrapper

 * @param int $fid
 *   The id of the file
 *
 * @param int $morphbank_specimen_id
 *   The Morphbank ID of the specimen
 */
function _remove_outdated_links($fid, $morphbank_specimen_id){
  if($fid > 0 && $morphbank_specimen_id > 0){
    // First grab all the specimen nodes that are associated with this $fid
    $node_query = db_select('field_data_field_media', 'f')->fields('f', array(
      'entity_id'
    ))->condition('entity_type', 'node', '=')->condition('bundle', 'specimen_observation', '=')->condition('field_media_fid', $fid, '=')->execute();
    // Loop over all specimen nodes with links to this fid
    foreach($node_query as $result){
      $nid = $result->entity_id;
      $node = node_load($nid);
      $wrapper = entity_metadata_wrapper('node', $node);
      $node_mb_id = $wrapper->field_morphbank_specimen_id->value();
      // Now see if any DO NOT have the same $morphbank_specimen_id
      if($node_mb_id != $morphbank_specimen_id){
        // Remove links for those without appropriate $morphbank_specimen_id
        $current_list = $wrapper->field_media->value();
        if($current_list){ // Hmmm...uncertain if $current_list would ever be empty (FALSE) at this point
          $new_list = array();
          $changed = FALSE;
          foreach($current_list as $list_item){
            if($fid == $list_item->fid){ // Same fid, remove link by omitting from list
              $changed = TRUE;
            }else{ // Different fid, keep link
              $new_list[] = $list_item;
            }
          }
          if($changed){ // At least one link was dropped, so save the new list
            try{
              $wrapper->field_media->set($new_list);
              $wrapper->save();
            }
            catch(Exception $exception){
              $exception_class = get_class($exception);
              watchdog('morphbank_harvest', t('Exception @class caught while attempting to remove outdated links between file @fid and specimens'), array(
                '@class' => $exception_class,
                '@fid' => $fid
              ), WATCHDOG_WARNING);
            }
          }
        } // End conditional for non-null $current_list
      } // End conditional for different morphbank specimen ids
    } // End looping over $node_query results
  } // End conditional for valid (positive) $fid and $morphbank_specimen_id
}